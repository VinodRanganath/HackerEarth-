import itertools

n = int(input("Enter number of values: ")) #Get user input for no. of values
N = [] #Initialize values list
MAXOR = 0 #Initialize MAXOR variable
XOR = [] #Initialize XOR list (for XOR of induvidual combinations)
combarray = [] #Initialize combarray list (for storing the list of combinations)
XORcomb = [] #Initialize XORcomb list (for storing XOR of all combinations)
index = [] #Initialize index list (to store indices of repeated XOR results)
finalcomb = [] #List to store the combinations with equal XOR results

#Get user input for values and store in array N
for e in range (1, n+1):
    elements = input("Enter element %r: " %e)
    N.append(int(elements))

print("List of values: %r" %N) #Display list of values
MAXOR = int(N[0]) #Assign initial value of array MAXOR 

#Find MAXOR for given array
for i in range (0, len(N)):
    MAXOR = MAXOR^int(N[i]) 

print("MAXOR = %r" %MAXOR) #Display MAXOR result

#Get the various non-repetitive combinations of values in the array
#and compute XOR for each combination and store in XORcomb list
for l in range (0, (len(N)+1)):
    for subset in itertools.combinations(N, l):
        #print(subset)
        combarray.append(subset)
        if len(subset)>1:
            XOR = int(subset[0])
            for s in range(0, len(subset)):
                XOR = XOR ^ int(subset[s])
        XORcomb.append(XOR)

#Function to acquire indices of repeated results
def duplicates(lst, item):
    return [j for j, x in enumerate(lst) if x == item]

#Display Combinations with equal results
for each in N:
    dups = duplicates(XORcomb, each)
    for index in range (0, len(dups)):        
        finalcomb.append(combarray[dups[index]])
    print("Combinations with XOR result of %r: %r" %(XORcomb[dups[index]], finalcomb))
    del finalcomb[:]
